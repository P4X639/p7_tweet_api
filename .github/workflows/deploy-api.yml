name: Deploy p7_tweet_api to Azure

# Declencheurs : quand lancer le workflow
on:
  push:
    branches: [ main ]
    paths:
      # Declencher seulement si ces fichiers/dossiers sont modifies
      - 'services/**'
      - 'Dockerfile'
      - 'docker-compose.yml'
      - 'requirements.txt'
      - '.github/workflows/**'
  
  # Permettre le declenchement manuel depuis l'interface GitHub
  workflow_dispatch:

# Variables d'environnement globales
env:
  DOCKER_IMAGE: docker.io/p4x639/p7-tweet-api
  DOCKER_TAG: latest
  AZURE_RESOURCE_GROUP: ${{ secrets.AZ_RESOURCE_GROUP }}
  AZURE_CONTAINER_NAME: ${{ secrets.AZ_CONTAINER }}
  AZURE_LOCATION: ${{ secrets.AZ_REGION }}
  AZ_INSTRUMENTATION_KEY: ${{ secrets.AZ_INSTRUMENTATION_KEY }}
  AZ_CONNECTION_STRING: ${{ secrets.AZ_CONNECTION_STRING }}
  AZ_WORKPLACE: ${{ secrets.AZ_WORKPLACE }}

jobs:
  # Job 1: Build et Push de l'image Docker
  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USER }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Build with docker-compose (like local)
      run: |
        # Creer un .env minimal pour docker compose build
        cat > .env << EOF
        # Variables minimales pour le build Docker
        PROJECT_SLUG=p7-tweet-api
        API_PORT=8000
        DASH_PORT=8050
        TF_ENABLE_ONEDNN_OPTS=0
        PYTHONUNBUFFERED=1
        EOF
        
        # Build exactement comme votre script local (avec Docker Compose V2)
        echo "Build avec docker compose (sans cache)..."
        docker compose build --no-cache
        
        # Verification que l'image est creee
        if docker images | grep -q "p4x639/p7-tweet-api"; then
          echo "[✓] Image creee avec succes"
        else
          echo "[X] Erreur: Image non creee"
          exit 1
        fi
    
    - name: Push to Docker Hub
      run: |
        echo "Push vers Docker Hub..."
        docker push p4x639/p7-tweet-api:latest
    
    - name: Test image locally
      run: |
        # Test que l'image se lance correctement
        docker run --rm -d \
          --name test-container \
          -p 8000:8000 \
          -e ENVIRONMENT=test \
          -e TF_ENABLE_ONEDNN_OPTS=0 \
          -e PYTHONUNBUFFERED=1 \
          -e MODEL_RUN_ID=test-mode \
          -e DAGSHUB_TOKEN=test-token \
          -e DAGSHUB_USERNAME=test \
          -e DAGSHUB_REPO=test \
          -e MLFLOW_TRACKING_URI=test \
          ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
        
        # Attendre le demarrage plus longtemps
        echo "[-] Attente du demarrage (30 secondes)..."
        sleep 30
        
        # Test de sante basique
        if curl -f http://localhost:8000/healthcheck --max-time 10; then
          echo "[✓] Image fonctionne correctement"
        else
          echo "[X] Erreur : Image ne repond pas"
          echo "Logs du container:"
          docker logs test-container
          exit 1
        fi
            
        # Nettoyage
        docker stop test-container

  # Job 2.5: Staging deployment + tests before production
  staging-tests:
    name: Staging Tests & Production Switch
    runs-on: ubuntu-latest
    needs: build-and-push
    
    env:
      AZURE_STAGING_CONTAINER: ${{ env.AZURE_CONTAINER_NAME }}-staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: |
          {
            "clientId": "${{ secrets.AZ_CLIENT_ID }}",
            "clientSecret": "${{ secrets.AZ_CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.AZ_SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.AZ_TENANT_ID }}"
          }
    
    - name: Set Azure subscription
      run: |
        az account set --subscription "${{ secrets.AZ_SUBSCRIPTION_ID }}"
        echo "[✓] Subscription active: $(az account show --query name --output tsv)"
    
    - name: Delete existing staging container
      run: |
        echo "[-] Suppression du container staging s'il existe..."
        if az container show \\
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
          --name ${{ env.AZURE_STAGING_CONTAINER }} \\
          --output none 2>/dev/null; then
          
          echo "[!] Container staging existant trouve - suppression..."
          az container delete \\
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
            --name ${{ env.AZURE_STAGING_CONTAINER }} \\
            --yes
          
          echo "[✓] Container staging supprime"
        else
          echo "[-] Aucun container staging existant"
        fi
    
    - name: Create staging container
      env:
        DEPLOYMENT_IMAGE: docker.io/p4x639/p7-tweet-api:latest
      run: |
        echo "[-] Creation du container staging pour tests..."
        az container create \\
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
          --name ${{ env.AZURE_STAGING_CONTAINER }} \\
          --image ${DEPLOYMENT_IMAGE} \\
          --cpu 1 \\
          --memory 1 \\
          --os-type Linux \\
          --restart-policy Always \\
          --ip-address Public \\
          --ports 8000 8050 \\
          --environment-variables \\
            'PYTHONUNBUFFERED=1' \\
            'TF_ENABLE_ONEDNN_OPTS=0' \\
            'ENVIRONMENT=staging' \\
            'API_HOST=0.0.0.0' \\
            'API_PORT=8000' \\
            'DASH_PORT=8050' \\
            'MODEL_RUN_ID=${{ secrets.MODEL_RUN_ID }}' \\
            'DAGSHUB_TOKEN=${{ secrets.DAGSHUB_TOKEN }}' \\
            'DAGSHUB_USERNAME=${{ secrets.DAGSHUB_USERNAME }}' \\
            'DAGSHUB_REPO=${{ secrets.DAGSHUB_REPO }}' \\
            'MLFLOW_TRACKING_URI=${{ secrets.MLFLOW_TRACKING_URI }}' \\
            'AZ_INSTRUMENTATION_KEY=${{ secrets.AZ_INSTRUMENTATION_KEY }}' \\
            'AZ_CONNECTION_STRING=${{ secrets.AZ_CONNECTION_STRING }}' \\
            'AZ_WORKPLACE=${{ secrets.AZ_WORKPLACE }}' \\
          --location ${{ env.AZURE_LOCATION }}
        
        echo "[✓] Container staging cree avec succes"
    
    - name: Wait for staging container startup
      run: |
        echo "[-] Attente du demarrage du container staging..."
        STAGING_IP=$(az container show \\
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
          --name ${{ env.AZURE_STAGING_CONTAINER }} \\
          --query ipAddress.ip \\
          --output tsv)
        
        echo "STAGING_IP=$STAGING_IP" >> $GITHUB_ENV
        echo "[!] IP staging: $STAGING_IP"
        
        for i in {1..20}; do
          if curl -f "http://$STAGING_IP:8000/healthcheck" --max-time 10 >/dev/null 2>&1; then
            echo "[✓] Container staging pret"
            break
          else
            echo "[-] Attente startup $i/20..."
            sleep 15
          fi
          
          if [ $i -eq 20 ]; then
            echo "[X] Container staging ne repond pas apres 5 minutes"
            exit 1
          fi
        done
    
    - name: Setup Python for tests
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install test dependencies
      run: |
        echo "[-] Installation des dependances de test..."
        pip install pytest pytest-json-report requests
        echo "[✓] Dependances installees"
    
    - name: Export staging API URL
      run: |
        echo "API_BASE_URL=http://$STAGING_IP:8000" >> $GITHUB_ENV
        echo "[✓] URL API staging configuree: http://$STAGING_IP:8000"
        
        echo "[-] Installation de jq pour l'analyse JSON..."
        sudo apt-get update -qq
        sudo apt-get install -y jq
        
        echo "[✓] Dependances installees (pytest, requests, jq)"
    
    - name: Run unit tests against staging
      run: |
        echo "[-] Execution des tests unitaires sur staging..."
        python -m pytest tests/test_api.py --json-report --json-report-file=staging_test_results.json -v --tb=short || echo "TEST_FAILED=true" >> $GITHUB_ENV
    
    - name: Analyze test results
      run: |
        if [ -f staging_test_results.json ]; then
          echo "[-] Analyse des resultats de tests..."
          
          # Extraire les resultats avec jq
          PASSED=$(jq -r '.summary.passed // 0' staging_test_results.json)
          TOTAL=$(jq -r '.summary.total // 0' staging_test_results.json)
          FAILED=$(jq -r '.summary.failed // 0' staging_test_results.json)
          
          echo "[!] Tests: $PASSED/$TOTAL passes"
          
          if [ "$FAILED" -gt 0 ]; then
            echo "[X] $FAILED tests echoues"
            echo "TEST_FAILED=true" >> $GITHUB_ENV
          else
            echo "[✓] Tous les tests passes"
          fi
        else
          echo "[X] Fichier de resultats de tests non trouve"
          echo "TEST_FAILED=true" >> $GITHUB_ENV
        fi
    
    - name: Production switch or staging cleanup
      run: |
        if [ "$TEST_FAILED" = "true" ]; then
          echo "[X] Tests echoues - suppression du staging"
          az container delete \\
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
            --name ${{ env.AZURE_STAGING_CONTAINER }} \\
            --yes
          echo "[✓] Container staging supprime"
          echo "DEPLOYMENT_STATUS=failed" >> $GITHUB_ENV
          exit 1
        else
          echo "[✓] Tests reussis - preparation basculement vers production"
          
          # Supprimer le container de production existant
          if az container show \\
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
            --name ${{ env.AZURE_CONTAINER_NAME }} \\
            --output none 2>/dev/null; then
            
            echo "[!] Suppression du container production existant..."
            az container delete \\
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
              --name ${{ env.AZURE_CONTAINER_NAME }} \\
              --yes
              
            # Attendre la suppression complete
            while az container show \\
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
              --name ${{ env.AZURE_CONTAINER_NAME }} \\
              --output none 2>/dev/null; do
              echo "[-] Attente suppression complete..."
              sleep 10
            done
            
            echo "[✓] Container production supprime"
          else
            echo "[-] Aucun container production existant"
          fi
          
          echo "DEPLOYMENT_STATUS=ready_for_production" >> $GITHUB_ENV
        fi
    
    - name: Upload staging test results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: staging-test-results
        path: staging_test_results.json
        retention-days: 30

  # Job 3: Production deployment (only if staging tests passed)
  deploy-to-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: staging-tests
    if: needs.staging-tests.result == 'success'
    
    steps:
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: |
          {
            "clientId": "${{ secrets.AZ_CLIENT_ID }}",
            "clientSecret": "${{ secrets.AZ_CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.AZ_SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.AZ_TENANT_ID }}"
          }
    
    - name: Set Azure subscription
      run: |
        az account set --subscription "${{ secrets.AZ_SUBSCRIPTION_ID }}"
        echo "[✓] Subscription configuree pour production"
    
    - name: Create production container
      env:
        DEPLOYMENT_IMAGE: docker.io/p4x639/p7-tweet-api:latest
        AZURE_STAGING_CONTAINER: ${{ env.AZURE_CONTAINER_NAME }}-staging
      run: |
        echo "[-] Creation du nouveau container production..."
        az container create \\
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
          --name ${{ env.AZURE_CONTAINER_NAME }} \\
          --image ${DEPLOYMENT_IMAGE} \\
          --cpu 1 \\
          --memory 1 \\
          --os-type Linux \\
          --restart-policy Always \\
          --ip-address Public \\
          --ports 8000 8050 \\
          --environment-variables \\
            'PYTHONUNBUFFERED=1' \\
            'TF_ENABLE_ONEDNN_OPTS=0' \\
            'ENVIRONMENT=production' \\
            'API_HOST=0.0.0.0' \\
            'API_PORT=8000' \\
            'DASH_PORT=8050' \\
            'MODEL_RUN_ID=${{ secrets.MODEL_RUN_ID }}' \\
            'DAGSHUB_TOKEN=${{ secrets.DAGSHUB_TOKEN }}' \\
            'DAGSHUB_USERNAME=${{ secrets.DAGSHUB_USERNAME }}' \\
            'DAGSHUB_REPO=${{ secrets.DAGSHUB_REPO }}' \\
            'MLFLOW_TRACKING_URI=${{ secrets.MLFLOW_TRACKING_URI }}' \\
            'AZ_CLIENT_ID=${{ secrets.AZ_CLIENT_ID }}' \\
            'AZ_CLIENT_SECRET=${{ secrets.AZ_CLIENT_SECRET }}' \\
            'AZ_CONTAINER=${{ secrets.AZ_CONTAINER }}' \\
            'AZ_RESOURCE_GROUP=${{ secrets.AZ_RESOURCE_GROUP }}' \\
            'AZ_REGION=${{ secrets.AZ_REGION }}' \\
            'AZ_SUBSCRIPTION_ID=${{ secrets.AZ_SUBSCRIPTION_ID }}' \\
            'AZ_SUBSCRIPTION_NAME=${{ secrets.AZ_SUBSCRIPTION_NAME }}' \\
            'AZ_TENANT_ID=${{ secrets.AZ_TENANT_ID }}' \\
            'AZ_INSTRUMENTATION_KEY=${{ secrets.AZ_INSTRUMENTATION_KEY }}' \\
            'AZ_CONNECTION_STRING=${{ secrets.AZ_CONNECTION_STRING }}' \\
            'AZ_WORKPLACE=${{ secrets.AZ_WORKPLACE }}' \\
            'SMS_URL=${{ secrets.SMS_URL }}' \\
            'SMS_USER=${{ secrets.SMS_USER }}' \\
            'SMS_PWD=${{ secrets.SMS_PWD }}' \\
          --location ${{ env.AZURE_LOCATION }}
        
        echo "[✓] Container production cree avec succes"
    
    - name: Cleanup staging container
      run: |
        echo "[-] Suppression du container staging..."
        az container delete \\
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
          --name ${{ env.AZURE_CONTAINER_NAME }}-staging \\
          --yes || echo "[!] Container staging deja supprime"
        echo "[✓] Container staging supprime"
    
    - name: Get production deployment info
      run: |
        echo "[-] Recuperation des informations de deploiement production..."
        sleep 10
        
        IP=$(az container show \\
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
          --name ${{ env.AZURE_CONTAINER_NAME }} \\
          --query ipAddress.ip \\
          --output tsv)
        
        if [ -n "$IP" ]; then
          echo "[✓] Deploiement production reussi !"
          echo "Votre API Tweet est accessible a:"
          echo "  - Documentation (FastAPI): http://$IP:8000"
          echo "  - Documentation (Swagger): http://$IP:8000/docs"
          echo "  - Interface API: http://$IP:8050"
          echo "  - Health check: http://$IP:8000/healthcheck"
          echo ""
          echo "Etat du container:"
          az container show \\
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
            --name ${{ env.AZURE_CONTAINER_NAME }} \\
            --query "{Name:name,State:containers[0].instanceView.currentState.state,IP:ipAddress.ip}" \\
            --output table
        else
          echo "[!] IP publique pas encore assignee"
          echo "Verifiez dans quelques minutes"
        fi
    
    - name: Production health check
      run: |
        echo "[-] Test de sante du deploiement production..."
        IP=$(az container show \\
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
          --name ${{ env.AZURE_CONTAINER_NAME }} \\
          --query ipAddress.ip \\
          --output tsv)
        
        if [ -n "$IP" ]; then
          echo "[-] Attente du demarrage de l'application..."
          for i in {1..12}; do
            if curl -f "http://$IP:8000/healthcheck" --max-time 10; then
              echo "[✓] Application production deployee et fonctionnelle !"
              exit 0
            else
              echo "[-] Tentative $i/12 - Application pas encore prete..."
              sleep 15
            fi
          done
          
          echo "[!] L'application ne repond pas aux tests de sante"
          echo "Logs du container:"
          az container logs \\
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \\
            --name ${{ env.AZURE_CONTAINER_NAME }}
        fi

  # Modifier votre job notify existant
  notify:
    name: Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, staging-tests, deploy-to-production]
    if: always()
    
    steps:
    - name: Deployment status
      run: |
        if [ "${{ needs.deploy-to-production.result }}" == "success" ]; then
          echo "[✓] Deploiement reussi avec tests valides !"
          echo "[✓] L'API Tweet est maintenant disponible en production"
          echo "[✓] Critere CE4 (Tests unitaires automatises) valide"
        elif [ "${{ needs.staging-tests.result }}" == "failure" ]; then
          echo "[X] Tests unitaires echoues - deploiement bloque"
          echo "[!] Verifiez les logs des tests staging"
        else
          echo "[X] Deploiement echoue"
          echo "[-] Verifiez les logs des jobs precedents"
        fi

    - name: Send SMS notification
      if: needs.deploy-to-production.result == 'success'
      run: |
        # Votre script SMS existant avec icônes
        cat > send_notification.py << 'EOF'
        import requests
        import sys
        import os
        
        def envoyer_sms(message):
            url = os.getenv('SMS_URL', 'https://smsapi.free-mobile.fr/sendmsg')
            params = {
                'user': os.getenv('SMS_USER'),
                'pass': os.getenv('SMS_PWD'),
                'msg': message
            }
            
            if not params['user'] or not params['pass']:
                print("[!] Variables SMS non configurees")
                return False
                
            response = requests.get(url, params=params)
            
            if response.status_code == 200:
                print("[✓] SMS envoye avec succes!")
                return True
            else:
                print(f"[X] Erreur lors de l'envoi du SMS: {response.status_code}")
                return False
        
        if __name__ == "__main__":
            message = "[✓] P7 Tweet API deployee avec succes sur Azure! Tests CE4 valides. L'application est maintenant en ligne."
            envoyer_sms(message)
EOF
        
        python send_notification.py
      env:
        SMS_URL: ${{ secrets.SMS_URL }}
        SMS_USER: ${{ secrets.SMS_USER }}
        SMS_PWD: ${{ secrets.SMS_PWD }}